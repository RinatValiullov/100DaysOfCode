<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>HighLoad Task</title>
</head>

<body>
    <!-- Вступление -->
    <section>
        <h1>Сравнение открытых OLAP-систем Big Data: ClickHouse, Druid и Pinot</h1>

        <p>
            Оригинал -<a href="https://medium.com/@leventov/comparison-of-the-open-source-olap-systems-for-big-data-clickhouse-druid-and-pinot-8e042a5ed1c7"
                title="original">https://medium.com/@leventov/comparison-of-the-open-source-olap-systems-for-big-data-clickhouse-druid-and-pinot-8e042a5ed1c7</a>
        </p>

        <p>
            <a href="https://clickhouse.yandex/" target="_blank">ClickHouse</a>, <a href="http://druid.io/"
                target="_blank">Druid</a>
            и <a href="https://github.com/apache/incubator-pinot" target="_blank">Pinot</a> – три
            открытых
            хранилища данных, которые позволяют выполнять аналитические запросы на больших объемах
            данных с интерактивными задержками.Этастатья - перевод <a href="https://medium.com/@leventov/comparison-of-the-open-source-olap-systems-for-big-data-clickhouse-druid-and-pinot-8e042a5ed1c7">подробного
                сравнения</a>,
            выполненного Романом Левентовым
        </p>
    </section>

    <!-- Источники -->
    <section>
        <h2>Источники информации</h2>
        <p>
            Подробности реализации <strong>ClickHouse</strong> стали мне известны от <a href="https://github.com/ztlpn"
                target="_blank" title="Алексей Зателепин">Алексея Зателепина</a>, одного из <strong>ключевых
                разработчиков проекта</strong>.
            Доступная на английском документация достаточно скудна –наилучшим источником информации
            служат последние четыре секции <a href="https://clickhouse.yandex/docs/en/development/architecture/"
                target="_blank">данной страницы документации</a>.
        </p>

        <p>
            <b>Я сам участвую в развитии Druid</b>, но у меня нет личной заинтересованности в этой
            системе - по правде говоря, скорее всего в ближайшеевремя я перестану заниматься
            еёразработкой. Поэтому читатели могут рассчитывать на отсутствие какой-либо
            предвзятости.
        </p>

        <p>
            Всё, что я буду далее писать про <b>Pinot</b>, основывается на странице <a href="https://github.com/apache/incubator-pinot/wiki/Architecture"
                target="_blank">Архитектура в вики Pinot</a>, а также на других страницах вики в
            разделе <span>&quot;Проектная документация&quot;</span>. Последний раз они обновлялись
            в июне 2017 года - больше, чем полгода назад.
        </p>

        <p>
            Рецензентами оригинальной статьи стали Алексей Зателепин и <a href="https://github.com/ludv1x"
                target="_blank" title="Виталий Людвиченко">Виталий Людвиченко</a> (разработчики
            ClickHouse), <a href="https://github.com/gianm" target="_blank" title="Жан Мерлино">Жан
                Мерлино</a> (самый активный разработчик Druid),
            <a href="https://github.com/kishoreg" target="_blank" title="Кишор Гопалакришна">Кишор
                Гопалакришна</a> (архитектор Pinot) и <a href="https://github.com/jfim" target="_blank"
                title="Жан-Француа Им">Жан-Француа Им</a> (разработчик Pinot). Мы
            присоединяемся к благодарности автора и полагаем, что это многократно повышает
            авторитетность статьи.
        </p>

        <p>
            <strong>Предупреждение</strong>: статья достаточно большая, поэтому вполне возможно
            вы захотите ограничиться прочтением раздела <span>&quot;Заключение&quot;</span> в
            конце.
        </p>
    </section>

    <!-- Сходства -->
    <section>
        <h2>Сходства между системами</h2>

        <!-- Связанные данные и вычисления -->
        <section>
            <h3>Связанные данные и вычисления</h3>

            <p>
                <b>На фундаментальном уровне, ClickHouse, Druid и Pinot похожи</b>, поскольку они
                хранят данные и выполняют обработку запросов на одних и тех же узлах, уходя от
                <span>&quot;разъединенной&quot;</span>
                архитектуры BigQuery. Недавно я уже описывал несколько наследственных проблем со
                связанной архитектурой в случае Druid [<a href="https://medium.com/@leventov/the-problems-with-druid-at-large-scale-and-high-load-part-1-714d475e84c9"
                    target="_blank">1</a>,
                <a href="https://medium.com/@leventov/the-challenges-of-running-druid-at-large-scale-and-future-directions-part-2-ef594ce298f2"
                    target="_blank">2</a>].
                Открытого эквивалента для BigQuery на данный момент не существует (за исключением,
                разве что, <a href="https://drill.apache.org" target="_blank">Drill</a>?)
                Возможным подходамк построению подобных открытых систем посвящена <a href="https://medium.com/@leventov/design-of-a-cost-efficient-time-series-store-for-big-data-88c5dc41af8e"
                    target="_blank">другая статья в моем блоге</a>.
            </p>
        </section>

        <!-- Отличия от Big Data SQL-систем -->
        <section>
            <h3>Отличия от Big Data SQL-систем: индексы и статическое распределение данных</h3>

            <p>
                Рассматриваемые в этой статье системы <strong>выполняют запросы быстрее</strong>,
                чем системы Big Data из семейства класса SQL-on-Hadoop: Hive, Impala, Presto и
                Spark, даже когда последние получают доступ к данным, хранящимся в колоночном
                формате -к примеру, Parquet или Kudu. Это происходит потому, что в ClickHouse,
                Druid и Pinot:
            </p>
            <ul>
                <li>
                    Имеется <strong>свой собственный формат для хранения данных с индексами</strong>,
                    и они тесно интегрированы с движками обработки запросов. Системы класса
                    SQL-on-Hadoop обычно можно назвать агностикамиотносительно форматовданных и
                    поэтому они менее <span>&quot;навязчивы&quot;</span> в бэкендах Big Data.</li>
                <li>
                    <b>Данные распределены относительно <span>&quot;статично&quot;</span></b> между
                    узлами, и при распределенном выполнении запроса это можно использовать.
                    Обратная сторона медали при этом в том, что ClickHouse, Druid и Pinot<strong>
                        не поддерживают запросы, которые требуют перемещения большого количества
                        данных</strong> между узлами - к примеру, join между двумя большими
                    таблицами.
                </li>
            </ul>
        </section>

        <!-- Отсутствие точечных обновлений и удалений -->
        <section>
            <h3>Отсутствие точечных обновлений и удалений</h3>

            <p>
                Находясь на другой стороне спектра баз данных, ClickHouse, Druid и Pinot <strong>не
                    поддерживают точечные обновления и удаления</strong>, в противоположность
                колоночным системам вроде Kudu, InfluxDB и Vertica (?). Это даёт ClickHouse, Druid
                и Pinot возможность производить более эффективное колоночное сжатие и более
                агрессивные индексы, что означает <strong>большую эффективность использования
                    ресурсов</strong> и быстрое выполнение запросов.
            </p>

            <p>
                Разработчики ClickHouse в Yandex планируют начать поддерживать <a href="https://clickhouse.yandex/docs/en/roadmap/#q1-2018"
                    target="_blank">обновления и удаления в будущем</a>, но я не уверен, будут ли
                это <span>&quot;настоящие&quot;</span> точечные запросы или обновления/удаления
                диапазонов данных.
            </p>
        </section>

        <!-- Поглощение в стиле Big Data -->
        <section>
            <h3>Поглощение в стиле Big Data</h3>

            <p>
                Все три системы поддерживают потоковое поглощение данных из Kafka. Druid и Pinot
                поддерживают потоковую передачу данных стриминг в <a href="https://en.wikipedia.org/wiki/Lambda_architecture"
                    target="_blank">Лямбда-стиле</a> и пакетное поглощение одних и тех же данных.
                ClickHouse поддерживает пакетные вставки напрямую, поэтому ему не требуется
                отдельная система пакетного поглощения подобная той, что используется в Druid и
                Pinot. Если вас интересуют подробности, то их вы сможете найти далее.
            </p>
        </section>

        <!-- Проверено на крупном масштабе -->
        <section>
            <h3>Проверено на крупном масштабе</h3>

            <p>
                Все три системы проверены на работоспособность в крупных масштабах: в <a href="https://clickhouse.yandex/blog/en/evolution-of-data-structures-in-yandex-metrica"
                    target="_blank">Yandex.Metrica работает кластер ClickHouse</a>, состоящий из
                примерно десятка тысяч ядер CPU. В Metamarkets используется <a href="https://medium.com/@leventov/the-problems-with-druid-at-large-scale-and-high-load-part-1-714d475e84c9"
                    target="_blank">кластер Druid аналогичного размера</a>. Один кластер Pinot в
                LinkedIn включает в себя <a href="https://github.com/apache/incubator-pinot/issues/3#issuecomment-228497765"
                    target="_blank"><span>&quot;тысячи машин&quot;</span></a>
            </p>
        </section>

        <!-- Незрелость -->
        <section>
            <h3>Незрелость</h3>

            <p>
                Все рассматриваемые в статье системы являются <strong>незрелыми по меркам открытых
                    enterprise-систем Big Data</strong>. Однако, скорее всего они незрелы не более,
                чем среднестатистическая открытая система Big Data - но это совсем другая история.
                В ClickHouse, Druid и Pinot недостает некоторых очевидных оптимизаций и
                функциональности, и они кишат багами (насчёт ClickHouse и Pinot я не уверен на все
                100%, но не вижу причин, по которым они в этом плане были бы лучше Druid).
            </p>
            <p>
                Это плавно подводит нас к следующему важному разделу.
            </p>
        </section>

    </section>

    <!-- Про сравнение производительности и выбор системы -->
    <section>
        <h2>Про сравнение производительности и выбор системы</h2>

        <p>
            Я регулярно вижу в сети, как некоторые проводят сравнения систем больших данных: они
            берут набор своих данных, каким-либо образом <span>&quot;скармливают&quot;</span> его
            оцениваемой системе, а затем немедленно пытаются измерить производительность - сколько
            памяти или дискового пространства было занято, и насколько быстро выполнялись запросы.
            Причем понимание того, как устроены изнутри испытываемые ими системы, у них
            отсутствует. Затем, используя лишь подобные специфичные данные о производительности -
            иногда вместе со списками функциональности, котораяим нужна и которая есть в системе <i>на
                настоящий момент</i>, - они в итоге делают свой выбор или, что ещё хуже, выбирают
            написать свою собственную, <span>&quot;лучшую&quot;</span> систему с нуля.
        </p>

        <p>
            Такой подход мне кажется неправильным, по крайней мере он неприменим в отношении
            открытых OLAP-систем для Big Data. Задача создания системы Bid Data OLAP, которая
            смогла бы работать эффективно в большинстве сценариев использования и содержала бы все
            необходимые функции настолько велика, что я оцениваю ее реализацию как минимум в <b>100
                человеко-лет</b>.
        </p>

        <p>
            На сегодня, ClickHouse, Druid и Pinot оптимизированы <i>только</i> для конкретных
            сценариев использования, которые требуются их разработчиком - и содержат по большей
            части лишь те функции, в которых нуждаются сами разработчики. Я могу гарантировать, что
            ваш случай обязательно <span>&quot;упрётся&quot;</span> в те узкие места, с которыми
            разработчики рассматриваемых OLAP-систем еще не сталкивались -или же в те места, что их
            не интересуют
        </p>

        <p>
            Не говоря уже о том, чтоупомянутый выше подход <span>&quot;забросить данные в систему,
                о которой вы ничего не знаете, и затем измерить её эффективность&quot;</span>
            весьма вероятно даст искаженный результат из-за серьезных <span>&quot;узких&quot;</span>
            мест, которые на самом деле могли бы быть исправлены <b>простым изменением конфигурации</b>,
            схемы данных или другим построением запроса.
        </p>
    </section>

    <!-- CloudFlare: ClickHouse против Druid -->
    <section>
        <h3>CloudFlare: ClickHouse против Druid</h3>

        <p>
            Одним таким примером, хорошо иллюстрирующим описанную выше проблему, является пост
            Марека Вавруша о выборе между <a href="https://blog.cloudflare.com/how-cloudflare-analyzes-1m-dns-queries-per-second/#comment-3302778860"
                target="_blank">ClickHouse и Druid в Cloudflare</a>. Им потребовалось 4 сервера
            ClickHouse (которые со временем превратились в 9), и по их оценкам, для разворачивания
            аналогичной установки Druid им бы потребовались <span>&quot;сотни узлов&quot;</span>.
            Пусть Марек и признает, что <b>сравнение является нечестным</b>, поскольку Druid
            недостаёт <span>&quot;сортировки по первичному ключу&quot;</span>, он возможно даже не
            осознает, что достичь примерно того же самого эффекта в Druid возможно просто <a href="http://druid.io/docs/0.11.0/ingestion/index.html"
                target=_blank>установив правильный порядок измерений в <i>&quot;ingestion
                    spec&quot;</i></a> и произведя простую подготовку данных: обрезать значение
            колонки <small>__time</small> в Druid до некоей грубой детализации (к примеру, один
            час) и опционально добавить другую <span>&quot;длинно-типовую&quot;</span> колонку
            <span>&quot;precise_time&quot;</span>,если для некоторых запросов требуются более
            точные временные рамки. Да, это хак, но, как мы только что выяснили, и в Druid можно
            сортировать данные по какому-либо измерению перед <small>__time</small>, и это
            достаточно просто реализовать
        </p>

        <p>
            Впрочем, я не стану спорить с их итоговым решением выбрать ClickHouse, поскольку на
            масштабе примерно в 10 узлов и для их нужд ClickHouse мне тоже кажется лучшим выбором,
            чем Druid. Но сделанное ими заключение о том, что ClickHouse как минимум на порядок
            эффективнее (по меркам стоимости инфраструктуры), чем Druid - это серьёзное
            заблуждение. На самом деле, из рассматриваемых нами сегодня систем, <strong>Druid
                предлагает наилучшую возможность для реально дешёвых установок</strong> (смотрите
            раздел <span>&quot;Уровни узлов обработки запросов в Druid&quot;</span> ниже)
        </p>

        <blockquote>
            Когда вы выбираете систему OLAP Big Data, не сравнивайте то, насколько они сейчас
            хорошо подходятдля вашего случая. Сейчас они все субоптимальны. Вместо этого, сравните,
            насколько быстро ваша компания способна заставить двигаться эти системы в том
            направлении, которое нужно именно вам.
        </blockquote>

        <p>
            В силу своей фундаментальной архитектурной схожести, ClickHouse, Druid и Pinot имеют
            примерно один и тот же <span>&quot;предел&quot;</span> эффективности и оптимизации
            производительности. Здесь нет <span>&quot;волшебной таблетки&quot;</span>, которая
            позволила бы какой-либо из этих систем быть быстрее, чем остальные. Не позволяйте
            запутать себя тем фактом, что <i>в своём текущем состоянии системы</i> показывают себя
            очень по-разному в различных бенчмарках.
        </p>

        <p>
            Допустим, Druid не поддерживает <span>&quot;сортировку по первичному ключу&quot;</span>
            настолько хорошо, насколько это умеет ClickHouse - а ClickHouse в свою очередь не
            поддерживает <span>&quot;инвертированные индексы&quot;</span> столь же хорошо, как
            Druid, что даёт данным системам преимущества с той или иной нагрузкой. <b>Упущенные
                оптимизации могут быть реализованы в выбранной системе при помощи не такихуж и
                больших усилий</b>, если у вас есть намерение и возможность решиться на подобный
            шаг.
        </p>

        <ul>
            <li>
                В вашей организации должны быть инженеры, способные прочитать, понять и
                модифицировать исходный код выбранной системы, к тому же у них должно быть на это
                время. Заметьте, что ClickHouse написан на C++, а Druid и Pinot — на Java.
            </li>
            <li>
                Или же ваша организация должна подписать контракт с компанией, которая оказывает
                поддержку выбранной системы. Этобудут <a href="https://www.altinity.com" target="_blank">Altinity</a>
                для ClickHouse, <a href="https://imply.io/services" target="_blank">Imply</a> и <a
                    href="https://hortonworks.com/open-source/druid/" target="_blank">Hortonworks</a>
                для Druid. Для Pinot таких компаний в данный момент нет.
            </li>
        </ul>

        <p>
            Другие сведения о разработке систем, которые вам стоит принять во внимание:
        </p>

        <ul>
            <li>
                Авторы ClickHouse, работающие в Yandex, утверждают, что они тратят 50% своего
                времени на создание функциональности, которая требуется им внутри компании, и
                другие 50% уходят на функции, который набирают большинство <span>&quot;голосов
                    сообщества&quot;</span>. Однако, чтобы вы получили от этого факта преимущество,
                требуется, чтобы <strong>функции, которые нужны вам, были и наиболее востребованы
                    сообществом</strong> ClickHouse.
            </li>
            <li>
                Разработчики Druid из Imply мотивированы работать над широко используемыми
                функциями, поскольку это позволит им максимально увеличить объем охвата своего
                бизнеса в будущем.
            </li>
            <li>
                Процесс разработки Druid сильно напоминает <a href="https://community.apache.org/apache-way/apache-project-maturity-model.html"
                    target="_blank">модель Apache</a>, когда ПО несколько лет разрабатывается
                несколькими компаниями, у каждой из который достаточно своеобразные и различные
                приоритеты, и среди них нет ведущей компании. ClickHouse и Pinot покаеще далеки от
                подобного этапа, поскольку ими занимаются соответственно лишь Yandex и Linkedin.
                Сторонний вклад в развитие Druid имеет минимальныйшанс быть отклоненным в силу
                того, что он расходится с видением основного разработчика -ведь <strong>в Druid нет
                    <span>&quot;основной&quot;</span> компании-разработчика</strong>.
            </li>
            <li>
                Druid поддерживает <span>&quot;API разработчика&quot;</span>, который позволяет
                привносить собственные типы колонок, механизмы агрегации, возможные варианты для
                <span>&laquo;глубокого хранения&raquo;</span> и пр., причем все это вы можете
                держать в кодовой базе, отдельной от самого ядра Druid. Данное API документировано
                разработчиками Druid, и они следят за его совместимостью с предыдущими версиями.
                Однако, оно недостаточно <span>&quot;взрослое&quot;</span>, и ломается практически
                с каждым новым релизом Druid. Насколько мне известно, в ClickHouse и Pinot схожие
                API не поддерживаются.
            </li>
            <li>
                Согласно Github, <b>над Pinot работает наибольшее число людей</b> - по всей
                видимости, лишь за прошлый год в Pinot было вложено <a href="https://github.com/apache/incubator-pinot/graphs/contributors?from=2017-01-24&to=2018-01-24&type=c"
                    target="_blank">не менее 10 человеко-лет</a>. Для ClickHouse эта цифра
                составляет примерно 6 человеко-лет, а для Druid - 7. В теории, это должно означать,
                что Pinot улучшается быстрее всех остальных систем, которые мы рассматриваем.
            </li>
        </ul>
        <p>
            Архитектуры Druid и Pinot почти что идентичны друг другу, в то время как ClickHouse
            стоит слегка в стороне. Поэтому сначала мысравним ClickHouse c <span>&quot;обобщенной&quot;</span>
            архитектурой Druid/Pinot, а затем обсудим мелкие различия между Druid и Pinot.
        </p>
    </section>

    <!-- Различия между ClickHouse и Druid/Pinot -->
    <section>
        <h2>Различия между ClickHouse и Druid/Pinot</h2>

        <!-- Управление данными: Druid и Pinot -->
        <section>
            <h3>Управление данными: Druid и Pinot</h3>

            <p>
                В Druid и Pinot, все данные в каждой <span>&quot;таблице&quot;</span> (как бы она
                не называлась в терминологии этих систем) разбиваются на указанное количество
                частей. По временой оси, данные обычно разделены сзаданыминтервалом. Затем эти
                части данных <span>&laquo;запечатываются&raquo;</span> индивидуально в
                самостоятельные автономные сущности, называемые <span>&laquo;сегментами&raquo;</span>.
                Каждый сегмент включает в себя метаданные таблицы, сжатые столбчатые данные и
                индексы.
            </p>

            <p>
                Сегменты хранятся в файловой системе хранилища <span>&laquo;глубокого
                    хранения&raquo;</span> (например, HDFS) и могут быть загружены на узлыобработки
                запросов, но последние не отвечают за устойчивость сегментов, поэтому узлыобработки
                запросов могут быть заменены относительно свободно. <b>Сегменты не привязаны жестко
                    к конкретным узлам</b> и могут быть загружены на те или другие узлы.
                Специальный выделенный сервер (который называется <span>&quot;координатором&quot;</span>
                в Druid и <span>&quot;контроллером&quot;</span> в Pinot, но я ниже обращаюсь к нему
                как к <span>&quot;мастеру&quot;</span>) отвечает за присвоение сегментов узлам, и
                перемещению сегментов между узлами,если потребуется.
            </p>

            <p>
                Это не противоречит тому, чтоя отмечал выше,все три системы имеют статическое
                распределение данных между узлами, поскольку загрузки сегментов и их перемещения в
                Druid - и насколько я понимаю в Pinot - являются дорогими операциями и потому не
                выполняются для каждой отдельной очереди, а происходятобычно раз в несколько
                минут/часов/дней.
            </p>

            <p>
                Метаданные сегментов хранятся в ZooKeeper - напрямую в случае Druid, и при помощи
                фреймворка <a href="https://helix.apache.org" target="_blank">Helix</a> в Pinot. В
                Druid метаданные также хранятся в базе SQL, об этом будет подробнеев разделе <span>&quot;Различия
                    между Druid и Pinot&quot;</span>.
            </p>
        </section>

        <!-- Управление данными: ClickHouse -->
        <section>
            <h3>Управление данными: ClickHouse</h3>

            <p>
                В ClickHouse нет <span>&quot;сегментов&quot;</span>, содержащих данные, попадающие
                в конкретные временные диапазоны. В нём нет <span>&quot;глубокого хранения&quot;</span>
                для данных, узлыв кластере ClickHouse также отвечают и за обработку запросов, и за
                постоянство/устойчивость данных, хранящихся на них. Так что вам <b>не потребуется
                    HDFS</b> или облачное хранилище данных вроде Amazon S3
            </p>

            <p>
                В ClickHouse имеются секционированные таблицы, состоящие из указанного набора
                узлов. Здесь нет <span>&quot;центральной власти&quot;</span> или сервера
                метаданных. Все узлы, между которыми разделената или иная таблица, содержат полные,
                идентичные копии метаданных, включая адреса всех остальных узлов, на которых
                хранятся секции этой таблицы.
            </p>

            <p>
                Метаданные секционированной таблицы включают <span>&quot;весы;&quot;</span>
                узловдля распределения свежезаписываемых данных - к примеру, 40% данных должны идти
                на узел A, 30% на узел B и 30% на C. Обычно же распределение должно происходить
                равномерно, <span>&quot;перекоос&quot;</span>, как в этомпримере, требуется только
                тогда, когда к секционированной таблице добавляется новый узел и нужно побыстрее
                заполнить его какими-либо данными. <strong>Обновления этих <span>&quot;весов&quot;</span>
                    должны выполняться вручную</strong> администраторами кластера ClickHouse, или
                же автоматизированной системой, построенной поверх ClickHouse.
            </p>
        </section>

        <!-- Управление данными: сравнение -->
        <section>
            <h3>Управление данными: сравнение</h3>

            <p>
                Подход к управлению данными в ClickHouse проще, чем в Druid и Pinot: не требуется
                <span>&quot;глубокого хранилища&quot;</span>, всего один тип узлов, не требуется
                выделенного сервера для управления данными. Но подход ClickHouse приводит к
                некоторым трудностям, когда любая таблица данных вырастает настолько большой, что
                требуется ее разбиение между десятком или более узлов: коэффициент усиления запроса
                становится настолько же велик, насколько и фактор секционирования - даже для
                запросов, которые покрывают небольшой интервал данных:
            </p>

            <figure>
                <img src="./images/data-management.png" alt="Компромисс распределения данных в ClickHouse">
                <figcaption><i>Компромисс распределения данных в ClickHouse</i></figcaption>
            </figure>

            <p>
                В примере, показанном на изображении выше, данные таблицы распределены между тремя
                узламив Druid/Pinot, но запрос по малому интервалу данных обычно затрагивает лишь
                два из них (до той поры, пока интервал не пересечет пограничный интервал сегмента).
                В ClickHouse, любые запросы будут вынуждены затронуть три узлв–если таблица
                сегментирована между тремя узлами. В данном примере разница не выглядит настолько
                существенно, однако представьте себе, что случится, если число узловдостигнет 100 –
                в то время как фактор сегментирования по-прежнему может быть равен, например, 10 в
                Druid/Pinot.
            </p>

            <p>
                Чтобы смягчить эту проблему, самый большой кластер ClickHouse в Яндексе, состоящий
                из сотен узлов, в действительности разбит на многие <span>&laquo;под-кластеры&raquo;</span>
                с несколькими десятками узловв каждом. Кластер ClickHouse используется в работе с
                аналитикой по веб-сайтам, и каждая точка данных имеет измерение <span>&laquo;ID
                    вебсайта&raquo;</span>. Существует жесткая привязка каждого ID сайта к
                конкретному под-кластеру, куда идут все данные для этого идентификатора сайта.
                Поверх кластера ClickHouse есть слой бизнес-логики, который управляет
                этимразделением данных при поглощении данных и выполнении запросов. К счастью, в их
                сценариях использования совсем немного запросов затрагивают несколько
                идентификаторов сайтов, и подобные запросы идут не от пользователей сервиса,
                поэтому у них нет жесткой привязки к реальному времени согласно соглашению об
                уровне услуг.
            </p>

            <p>
                Другим недостатком подхода ClickHouse является то, что,когда кластер растет очень
                быстро, данные не могут перебалансироваться автоматически без участия человека,
                который вручную поменяет <span>&laquo;веса&raquo;</span> узловв разбиваемой
                таблице.
            </p>
        </section>

        <!-- Уровни узлов обработки запросов в Druid -->
        <section>
            <h3>Уровни узлов обработки запросов в Druid</h3>

            <p>
                Управление данными при помощи сегментов «проще себе представить» - эта концепция
                хорошо ложится на наши когнитивные способности. Сами сегменты можно перемещать
                между узлами относительно просто. Эта две причины позволили Druid реализовать <span>&quot;разделение
                    на уровни&quot;</span> узлов, занимающихся обработкой запросов: старые данные
                автоматически перемещаются на сервера с относительно большими дисками, но меньшим
                количеством памяти и CPU, что позволяет <strong>значительно снизить стоимость
                    большого рабочего кластера Druid</strong> за счет замедления запросов к более
                старым данным
            </p>

            <p>
                Эта функция позволяет Metamarkets экономить сотни тысяч долларов расходов на
                инфраструктуру Druid каждый месяц - в противовес тому варианту, если бы
                использовался <span>&quot;плоский&quot;</span> кластер
            </p>

            <figure>
                <img src="./images/levels.png" alt="Уровни узловобработки запросов в Druid">
                <figcaption>Уровни узловобработки запросов в Druid</figcaption>
            </figure>

            <p>
                Насколько мне известно, в ClickHouse и Pinot пока еще нет похожей функциональности
                - предполагается, что все узлы в их кластерах одинаковы
            </p>

            <p>
                В силу того, что архитектура Pinotвесьма схожа с архитектурой Druid, как мне
                кажется, будет не слишком сложно добавить аналогичную функцию в Pinot. Тяжелее
                будет в случае с ClickHouse, поскольку для реализации данной функции крайне полезно
                использование концепта <span>&quot;сегментов&quot;</span>, однако это всё равно
                возможно.
            </p>
        </section>

        <!-- Репликация данных: Druid и Pinot -->
        <section>
            <h3>Репликация данных: Druid и Pinot</h3>

            <p>
                Единицей репликации в Druid и Pinot является единичный сегмент. Сегменты
                реплицируются на уровне «глубокого хранения» (например, в три реплики на HDFS, или
                при помощи хранилища BLOB-объектов в Amazon S3), и на уровне обработки запросов:
                обычно и вDruid ивPinot, каждый сегмент загружается на дваразличныхузла.
                «Мастер»-сервер мониторит уровни репликации для каждого сегмента и загружает
                сегмент на какой-либо сервер, если фактор репликации падает ниже заданного уровня
                (например, если какой-либо из узловперестаёт отвечать).
            </p>
        </section>

        <!-- Репликация данных: ClickHouse -->
        <section>
            <h3>Репликация данных: ClickHouse</h3>

            <p>
                Единицей репликации в ClickHouse является секция таблицы на сервере (например, все
                данные из какой-либо таблицы, хранящиеся на сервере). Аналогично секционированию,
                репликация в ClickHouse является скорее «статической и конкретной»,чем «в облачном
                стиле»: несколько серверов знают, что они являются репликами друг друга (для
                некоторойконкретной таблицы; в случае другой таблицы, конфигурация репликации может
                отличаться). Репликация предоставляет и устойчивость, и доступность запросов. Когда
                повреждается диск на одномузле, данные не теряются, поскольку они хранятся еще и на
                другомузле. Когда какой-либо узел временно недоступен, запросы могут быть
                перенаправлены на реплику.
            </p>

            <p>
                В самом большом кластере ClickHouse в Яндексе есть два одинаковых набора узловв
                различных дата-центрах, и они спарены. В каждой паре узлыявляются репликами друг
                друга (используется фактор репликации, равный двум), и они расположены в различных
                дата-центрах.
            </p>

            <p>
                ClickHouse полагается на ZooKeeper для управления репликацией –поэтому, если вам не
                нужна репликация, то вам не нужен и ZooKeeper. Это означает, что ZooKeeper не
                потребуется и для ClickHouse, развернутого на одиночном узле.
            </p>
        </section>

        <!-- Поглощение данных: Druid и Pinot -->
        <section>
            <h3>Поглощение данных: Druid и Pinot</h3>

            <p>
                В Druid и Pinot узлыо бработки запросов специализируются на загрузке сегментов и
                обслуживают запросы к данным в сегментах; они не занимаются накоплением новых
                данных и производством новых сегментов.
            </p>

            <p>
                Когда таблица может обновляться с задержкой в час или более, сегменты создаются при
                помощи движков пакетной обработки –к примеру, Hadoop или Spark. И в Druid, и в
                Pinot есть первоклассная поддержка Hadoop из коробки. Существует <a href="https://github.com/metamx/druid-spark-batch"
                    target="_blank">сторонний плагин для поддержки индексации Druid в Spark</a>, но
                в данный момент официально он не поддерживается. Насколько мне известно, в Pinot
                такого уровня поддержки Spark пока нет, то есть вы должны быть готовы разобраться с
                интерфейсами Pinot и кодом, азатем самостоятельно написать код на Java/Scala, пусть
                это и не должно быть слишком сложно. (Впрочем, с момента публикации оригинальной
                статьи поддержка Sparkв Pinot <a href="https://github.com/apache/incubator-pinot/pull/2388"
                    target="_blank">была внесена контрибьютором</a>).
            </p>

            <p>
                Когда таблица должна обновляться в реальном времени, здесь приходит на помощь идея
                <span>&quot;реалтаймовых&quot;</span> узлов, которыеделают три вещи: принимает
                новые данные из Kafka (Druid поддерживает и другие источники), обслуживает запросы
                с недавними данными, создает сегменты в фоне и затем записываетих в <span>&quot;глубокое
                    хранилище&quot;</span>.
            </p>
        </section>

        <!-- Поглощение данных: ClickHouse -->
        <section>
            <h3>Поглощение данных: ClickHouse</h3>

            <p>
                Тот факт, что ClickHouse не требуется готовить <span>&quot;сегменты&quot;</span>,
                содержащие все данные и попадающие в заданные временные интервалы, позволяет
                строить более простую архитектуру поглощения данных. ClickHouse не требуется ни
                пакетный движок обработки вроде Hadoop, ни <span>&quot;реалтаймовые&quot;</span>
                узлы. Обычные узлы ClickHouse - те же самые, что занимаются хранением данных и
                обслуживают запросы к ним -напрямую принимают пакетные записи данных.
            </p>

            <p>
                Если таблица разбита на сегменты, то узел, которыйпринимает пакетную запись
                (например, 10к строк) распределяет данные согласно <span>&quot;весам&quot;</span>
                (смотрите раздел ниже).Строки записываются одним пакетом, который формирует
                небольшое <span>&quot;множество&quot;</span>. Множество немедленно конвертируется в
                колоночный формат. На каждом узле ClickHouse работает фоновый процесс, который
                объединяет наборы строк в еще большие наборы. Документация ClickHouse сильно
                завязана на принцип, известный как <span>&quot;MergeTree&quot;</span>, и
                подчеркивает схожесть его работы с <a href="https://ru.wikipedia.org/wiki/LSM-дерево"
                    target="_blank">LSM-деревом</a>я это слегка смущает, поскольку данные не
                организованы в деревья - они лежат в плоском колончатом формате.
            </p>
        </section>

        <!-- Поглощение данных: сравнение -->
        <section>
            <h3>Поглощение данных: сравнение</h3>

            <p>
                Поглощение данных в Druid и Pinot является <span>&quot;тяжелым&quot;</span>: оно
                состоит из нескольких различных сервисов, и управление ими - это тяжелый труд.
            </p>

            <p>
                Поглощение данных в ClickHouse гораздо проще (что компенсируется сложностью
                управления <span>&quot;историческими&quot;</span> данными - т.е. данными не в
                реальном времени), но и здесь есть один момент: вы должны иметь возможность
                собирать данные в пакеты до самого ClickHouse. Автоматическое поглощение и пакетный
                сбор данных из <a href="https://clickhouse.yandex/docs/en/operations/table_engines/kafka/"
                    target="_blank">Kafka доступно <span>&quot;из коробки&quot;</span></a>, но если
                у вас используется другой источник данных в реальном времени (здесь подразумевается
                всё, что угодно, в диапазоне между инфраструктурой запросов, альтернативной Kafka,
                и стриминговых движков обработки, вплоть до различных HTTP-endpoint), то вам
                придется создать промежуточный сервис по сбору пакетов, или же внестикод напрямую в
                ClickHouse.
            </p>
        </section>

        <!-- Выполнение запроса -->
        <section>
            <h3>Выполнение запроса</h3>

            <p>
                В <b>Druid и Pinot</b> имеется отдельный слой узлов, называемых <span>&quot;брокерами&quot;</span>,
                которые принимают все запросы к системе. Они определяют, к каким <span>&quot;историческим&quot;</span>
                (содержащим данные не в реальном времени) узламобработки запросов должны быть
                отправлены подзапросы, основываясь на отображении сегментов в узлы, в которых
                сегменты загружаются. Брокеры хранят информацию об отображении в памяти.
                Брокер-узлыотправляют дальше подзапросы к узламобработки запросов, и когда
                результаты этих подзапросов возвращаются, брокер объединяет их и возвращает
                финальный комбинированный результат пользователю.
            </p>

            <p>
                Я не берусь предполагать, зачем при проектировании Druid и Pinot было принято
                решение о введенииеще одного типа узлов. Однако, теперь они кажутся их неотъемлемой
                частью, поскольку,когда общее количество сегментов в кластере начинает превышать
                десять миллионов, информация об отображениисегментов в узлыначинает занимать
                гигабайты памяти. Это очень расточительно –выделять столько много памяти на каждом
                узледля обработки запросов. Вот вам и еще один недостаток, который накладывается на
                Druid и Pinot их «сегментированной» архитектурой управления данными.
            </p>

            <p>
                В ClickHouse выделять отдельный набор узловпод <span>&quot;брокер запросов&quot;</span>
                обычно не требуется. Существует специальный, эфемерный <a href="https://clickhouse.yandex/docs/en/operations/table_engines/distributed/"
                    target="_blank"><span>&quot;распределенный&quot;</span> тип таблицы</a> в
                ClickHouse, который может быть установлен на любом узле, и запросы к этой таблице
                будут делать все то же, за что отвечают брокер - узлы в Druid иPinot. Обычно
                подобные эфемерные таблицы размещаются на каждом узле, который участвует в
                секционированной таблице, так что на практике каждый узел может быть <span>&quot;входной
                    точкой&quot;</span> для запроса в кластер ClickHouse. Этот узелможет выпускать
                необходимые подзапросы к другим секциями, обрабатывать свою часть запроса
                самостоятельно и затем объединять её с частичными результатами от других секций.
            </p>

            <p>
                Когда узел (или один из процессинговых узловв ClickHouse, или брокер - узел в Druid
                и Pinot) выпускает подзапросы к другим, и один или несколько подзапросов по
                какой-либо причине заканчиваются неудачей, ClickHouse и Pinot обрабатывают эту
                ситуацию правильно: они объединяют результаты успешно выполненных подзапросов
                вместе, и всё равно возвращают частичный результат пользователю. <a href="https://medium.com/@leventov/the-problems-with-druid-at-large-scale-and-high-load-part-1-714d475e84c9"
                    target="_blank">Druid этой функции сейчас очень недостает</a>: если в нем
                выполнение подзапроса заканчивается неудачей, то неудачей закончится и весь запрос
                целиком.
            </p>
        </section>

        <!-- ClickHouse vs. Druid или Pinot: Выводы -->
        <section>
            <h3>ClickHouse vs. Druid или Pinot: Выводы</h3>

            <p>
                <span>&quot;Сегментированный&quot;</span> подход к управлению даннымив Druid и
                Pinot против более простого управления данными в ClickHouse определяет многие
                аспекты систем. Однако, важно заметить, что это различие оказываетнебольшое(или не
                оказываетвовсе) влияниена потенциальную эффективность сжатия (впрочем, история про
                компрессию для всех трех систем имеет печальный конец по нынешнему состоянию дел),
                или на скорость обработки запросов.
            </p>

            <p>
                <b>ClickHouse</b> похож на традиционные RDMBS, например, PostgreSQL. В частности,
                ClickHouse можно развернутьна всего один сервер. Если планируемый размер невелик -
                скажем, не больше порядка 100 ядер CPU для обработки запросов и 1 TB данных, я бы
                сказал, что ClickHouse имеет значительные преимущества перед Druid и Pinot в силу
                своей простоты и отсутствия необходимости в дополнительных типах узлов, таких как
                <span>&quot;мастер&quot;</span>, <span>&quot;узлы поглощения в реальном
                    времени&quot;</span>, <span>&quot;брокеры&quot;</span>. На этом поле,
                ClickHouse соревнуется скорее с InfluxDB, чем с Druid или Pinot.
            </p>

            <p>
                <b>Druid and Pinot</b> похож на системы Big Data вроде HBase. Здесь в виду имеются
                не характеристики производительности, а зависимость от ZooKeper, зависимость от
                персистентного реплицируемого хранилища (к примеру, HDFS), сосредоточение внимания
                на устойчивости к отказам отдельных узлов, а также автономная работа и управление
                данными, не требующими постоянного внимания человека.
            </p>

            <p>
                Для широкого спектра приложений, ни ClickHouse, ни Druid или Pinot не являются
                очевидными победителями. В первую очередь, вы должны принимать во внимание вашу
                способность разобраться с исходным кодом системы, исправлять баги, добавлять
                новыефункциии т.д. Это подробнее обсуждается в разделе <span>&quot;Про сравнение
                    производительности и выбор системы&quot;</span>.
            </p>

            <p>
                Во-вторых, вам стоит взглянуть на таблицу ниже. Каждая ячейка в этой таблице
                описывает свойство приложения, которое позволит определить предпочтительную
                систему. Строки отсортированы нев порядке важности. Важность различных свойств
                может разниться от приложения к приложению, но в целом можно применить следующий
                подход: если ваше приложение соответствует подавляющему большинству строк со
                свойствами в одной из колонок, то относящаяся к ней система в вашем случае является
                предпочтительным выбором.
            </p>

            <!-- Аттрибут border устарел, а инлайновые стили использованы мной исключительно в оформительских целях для соответсвия заданию (РЕКОМЕНДУЕТСЯ ИСПОЛЬЗОВАТЬ ВНЕШНИЙ CSS) -->
            <table border="1" style="border-collapse: collapse;">
                <thead>
                    <tr>
                        <th>ClickHouse</th>
                        <th>Druid или Pinot</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>В организации есть эксперты по C++</td>
                        <td>В организации есть эксперты по Java</td>
                    </tr>
                    <tr>
                        <td>Малый кластер</td>
                        <td>Большой кластер</td>
                    </tr>
                    <tr>
                        <td>Немного таблиц</td>
                        <td>Много таблиц</td>
                    </tr>
                    <tr>
                        <td>Один набор данных</td>
                        <td>Несколько несвязанных наборов данных</td>
                    </tr>
                    <tr>
                        <td>Таблицы и данныенаходятся в кластере перманентно</td>
                        <td>Таблицы и наборыданных периодически появляются в кластере и удаляются
                            из него</td>
                    </tr>
                    <tr>
                        <td>Размер таблиц (и интенсивность запросов к ним) остается стабильным во
                            времени</td>
                        <td>Таблицы значительно растут и сжимаются</td>
                    </tr>
                    <tr>
                        <td>Однородные запросы (их тип, размер, распределение по времени суток и
                            т.д.)</td>
                        <td>Разнородные запросы</td>
                    </tr>
                    <tr>
                        <td>В данных есть измерение, по которому оно может быть сегментировано, и
                            почти не выполняется запросов, которые затрагивают данные,
                            расположенные внескольких сегментах</td>
                        <td>Подобного измерения нет, и запросы часто затрагивают данные,
                            расположенные во всем кластере</td>
                    </tr>
                    <tr>
                        <td>Облако не используется, кластер должен быть развернут на специфическую
                            конфигурацию физических серверов</td>
                        <td>Кластер развернут в облаке</td>
                    </tr>
                    <tr>
                        <td>Нет существующих кластеров Hadoop или Spark</td>
                        <td>Кластеры Hadoop или Spark уже существуют и могутбыть использованы</td>
                    </tr>
                </tbody>
            </table>

            <p>
                <b>Примечание</b>: ни одно из свойств выше не означает, что вы должны использовать
                соответствующую систему (системы), или избегать другую. К примеру, если
                планируется, что ваш кластер будет большим, это не значит, чтовыобязательно должны
                рассматривать только Druid или Pinot, исключив ClickHouse. Скорее всего, в данной
                ситуации Druid или Pinot могут быть лучшим выбором, но другие полезные свойства
                могут перевесить чашу весов в сторону ClickHouse, который для некоторых приложений
                является оптимальным выбором даже для больших кластеров.
            </p>
        </section>

    </section>

    <!-- Различия между Druid и Pinot -->
    <section>
        <h2>Различия между Druid и Pinot</h2>

        <p>
            Как уже не раз отмечалось в данной статье, Druid и Pinot имеют весьма похожие
            архитектуры. Есть несколько достаточно заметных особенностей, которые есть в одной
            системе и отсутствуют в другой, и областей, в которых каждая из систем развита гораздо
            сильнее другой. Тем не менее, всё, о чем я собираюсь упомянуть ниже, можно
            воспроизвести в другой системе, приложив разумное количество усилий.
        </p>

        <p>
            Между Druid и Pinot существует лишь <strong>одно существенное различие</strong>,
            которое слишком велико для того, чтобы от него избавились в обозримом будущем - это
            <strong>реализация управления сегментами</strong> в мастер-ноде. Кстати, разработчики
            обеих систем наверняка не хотели бы этого делать в любом случае, поскольку оба подхода
            имеют свои <span>&quot;за&quot;</span> и <span>&quot;против&quot;</span> - среди них
            нет такого, который был бы лучше.
        </p>

        <!-- Управление сегментами в Druid -->
        <section>
            <h3>Управление сегментами в Druid</h3>

            <p>
                Мастер-нодав Druid (и ни один из узловв Pinot) не отвечают за сохранность
                метаданных в сегментах данных в кластере, и текущее отображение между сегментами и
                узламиобработки данных, на которых загружены сегменты. Эта информация хранится в
                ZooKeeper. Однако, Druid в дополнениехранит эту информацию еще и в SQL базе данных,
                которая необходимадля развертывания кластера Druid. Не могу сказать, с какой целью
                было принято такоерешение, но сейчас оно дает следующие преимущества:
            </p>

            <ul>
                <li>
                    В ZooKeeper <b>хранится меньше данных</b>. Только минимум информации об
                    отображении идентификатора сегмента на список узлов,занимающихся обработкой
                    запросов, куда загружен сегмент, сохраняется в ZooKeeper. Оставшиеся
                    метаданные, к примеру, размер сегмента, список измерений и метрики, и т.д.
                    -хранятся только в SQL базе данных.
                </li>

                <li>
                    Когда сегменты данных вытесняются из кластера, поскольку они становятся слишком
                    старыми (это общая функция всех баз данных временных рядов - она есть и в
                    ClickHouse, и в Druid, и в Pinot), они выгружаются из узловобработки запросов и
                    их метаданные удаляются из ZooKeeper, но не из <span>&quot;глубокого
                        хранилища&quot;</span> и не из базы данных SQL. Пока они не будут удалены
                    из этих мест вручную, <b>остается возможность <span>&quot;оживить&quot;</span>
                        действительно старые данные быстро</b>, если онпотребуются для
                    построенияотчетов или исследований.
                </li>

                <li>
                    Вряд ли это планировалось с самого начала, но теперь есть планы сделать <strong>зависимость
                        Druid от ZooKeeper опциональной</strong>. Сейчас ZooKeeper используется для
                    трех различных функций: управления сегментами, обнаружениясервисов и хранения
                    свойств (например, для управления поглощением данных в реальном времени).
                    Обнаружение сервисов может быть предоставлено Consul. Управление сегментами
                    может бытьреализовано при помощи HTTP-команд, и оно доступно нам благодаря
                    тому, что функциихранения в ZooKeeper <span>&quot;бекапится&quot;</span> в базе
                    SQL.
                </li>
            </ul>

            <p>
                То что нам приходится иметь в зависимостях базу данных SQL, приводит кбольшей
                нагрузке на эксплуатацию,особенно,если в компании еще не использовалась какая-либо
                БД SQL. Druid поддерживает MySQL и PostgreSQL, есть и расширение для Microsoft SQL
                Server. Кроме того, когда Druid рразворачиваетсяв облаке, можно использовать
                стандартные сервисы для управления RDBMS -к примеру, Amazon RDS.
            </p>

        </section>

        <!-- Управление сегментами в Pinot -->
        <section>
            <h3>Управление сегментами в Pinot</h3>

            <p>
                В отличие от Druid, который реализует всю логику управления сегментами
                самостоятельно и полагается только на <a href="https://curator.apache.org" target="_blank">Curator</a>
                для взаимодействияс ZooKeeper, Pinot делегирует большую часть логики управления
                сегментами и кластерами на <a href="https://helix.apache.org" target="_blank">фреймворк
                    Helix</a>.
            </p>

            <p>
                С одной стороны, я могу понять, что это дает разработчикам Pinot возможность
                сосредоточиться на других частях их системы. В Helix возможно меньше багов, чем в
                логике внутри самого Druid, поскольку он тестируется в других условиях и поскольку
                в него, предположительно, было вложено гораздо больше рабочего времени.
            </p>

            <p>
                С другой стороны, Helix возможно ограничивает Pinot своими <span>&quot;рамками
                    фреймворка&quot;</span>. Helix, и следовательно, <b>Pinot, скорее всего будут
                    зависеть от ZooKeeper всегда</b>.
            </p>

            <p>
                Далее я собираюсь перечислить менееважные различия между Druid и Pinot -в том
                смысле, что если у вас возникнет серьезное желание повторить одну из этих функцийв
                вашей системе, то это будет вполне осуществимо.
            </p>

        </section>

        <!-- «Проталкивание предикатов» в Pinot -->
        <section>
            <h3><span>&laquo;Проталкивание предикатов&raquo;</span> в Pinot</h3>

            <p>
                Если во время поглощения данные секционируются в Kafka по каким-либо ключам
                измерений, Pinot создаёт сегменты, которые содержат информацию об этом разбиениии
                затем,когда выполняется запрос с предикатом на данном измерении, брокер-узел
                фильтрует сегменты таким образом, чтобы как можно меньше сегментов и узлов
                обработки запросов было затронуто.
            </p>

            <p>
                Эта концепцияв оригинале называется <b>&quot;predicate pushdown&quot;</b> и важна
                для поддержания высокой производительности в некоторых приложениях.
            </p>

            <p>
                На данный момент Druid поддерживает разбиениепо ключам, если сегменты были созданы
                в Hadoop, но еще не поддерживает сегменты, созданные во время поглощения в реальном
                времени. Druid сейчас не реализует функцию «проталкивания предикатов» на брокеры.
            </p>

        </section>

        <!-- Сменный Druid и своевольный Pinot -->
        <section>
            <h3><span>&quot;Сменный&quot;</span> Druid и своевольный Pinot</h3>

            <p>
                Поскольку Druid используют различныеорганизациии в его разработке принимают участие
                несколько компаний, он обзавелся поддержкой нескольких взаимозаменяемых опций для
                практически любой выделенной части или <span>&quot;сервиса&quot;</span>:
            </p>

            <ul>
                <li>
                    HDFS, Cassandra, Amazon S3, Google Cloud Storage или Azure Blob Storage и т.д.
                    в качестве <span>&quot;глубокого хранилища&quot;</span>;
                </li>

                <li>
                    Kafka, илиr RabbitMQ, Samza, или Flink, или Spark, Storm, и т.д. (через <a href="https://github.com/druid-io/tranquility"
                        target="_blank">Tranquility</a>) в качестве источника поглощения данных в
                    реальном времени;
                </li>

                <li>
                    Сам Druid, илиGraphite, или Ambari, или StatsD, или Kafka в качестве <span>&quot;слива&quot;</span>
                    для телеметрии кластера Druid (метрик).
                </li>
            </ul>

            <p>
                В то же время Pinot почти целиком разрабатывался исключительно в стенах LinkedIn и
                должен был удовлетворять текущим нуждам компании, поэтому выбор, который вам
                предлагается, не так велик.Вкачестве <span>&quot;глубокого хранилища&quot;</span>
                необходимо использовать HDFS или Amazon S3, а для поглощения данных в реальном
                времени подойдет только Kafka. Но если кому-то это действительно понадобится, мне
                кажется, не составит особой сложности добавить поддержку любого другого сервиса в
                Pinot. К тому же, можно ожидать позитивных сдвигов в этом направлении, поскольку <a
                    href="https://www.slideshare.net/XIANGFU3/pinot-near-realtime-analytics-uber"
                    target="_blank">Uber</a> и Slack начинают использовать Pinot.
            </p>

        </section>

        <!-- Формат данных и движок выполнения запросов лучше оптимизированы в Pinot -->
        <section>
            <h3>Формат данных и движок выполнения запросов лучше оптимизированы в Pinot</h3>

            <p>
                В частности, следующие функции формата сегментов Pinotсейчас отсутствуют в Druid:
            </p>

            <ul>
                <li>
                    <b>Сжатие проиндексированных столбцов</b> с битовой гранулярностью, но байтовой
                    гранулярностью в Druid/
                </li>

                <li>
                    <b>Инвертированный индекс опционален</b> для каждого столбца. В Druid он
                    является обязательным, иногда этого не требуется, но все равнозанимает много
                    места. Различие в потреблении места между Druid и Pinot, <a href="https://www.slideshare.net/XIANGFU3/pinot-near-realtime-analytics-uber/17"
                        target="_blank">на которое указывает Uber в своих тестах</a>, вполне
                    возможно вызваноименно этим.
                </li>

                <li>
                    <b>Минимальные и максимальные значения</b> в числовых столбцах записываются
                    посегментно.
                </li>

                <li>
                    <b>Поддержка сортировки данных из коробки</b>. В Druid этого можно достичь
                    только вручную и слегка специфическим способом (как было описано в разделе
                    <span>&quot;CloudFlare: ClickHouse против Druid&quot;</span>). Сортировка
                    данных означает лучшее сжатие, и эта функция в Pinot - ещё одна причина
                    различия между Druid и Pinot в потреблении пространства (и производительности
                    запросов!), на которую указывает Uber.
                </li>

                <li>
                    <b>Формат данных</b>, используемый для многозначных столбцов, на данный момент
                    лучше оптимизирован в Pinot, чем в Druid.
                </li>

            </ul>

            <p>
                Однако, все это можно реализовать и в Druid. И несмотря на то, что формат Pinot
                оптимизирован существенно лучше, чем формат Druid, он все равно достаточно далек от
                того, чтобы быть оптимальным. Один из примеров: Pinot (как и Druid) использует
                только сжатие общего назначение (как Zstd) и еще не реализовали идеи сжатия из <a
                    href="chrome-extension://oemmndcbldboiebfnladdacbdfmadadm/http://www.vldb.org/pvldb/vol8/p1816-teller.pdf"
                    target="_blank">Gorilla</a>.
            </p>

            <p>
                Ксожалению Uber по большей части использовал запросы <code>count (*)</code> для
                сравнения производительности Druid и Pinot относительно выполнения запроса [<a href="https://www.slideshare.net/XIANGFU3/pinot-near-realtime-analytics-uber/18"
                    target="_blank">1</a>, <a href="https://www.slideshare.net/XIANGFU3/pinot-near-realtime-analytics-uber/19"
                    target="_blank">2</a>], который сейчас в Druid представляет собой тупое
                линейное сканирование, хотя его и несложно заменить <a href="https://github.com/apache/incubator-druid/issues/4065#issuecomment-286963235"
                    target="_blank">корректной O(1) реализацией</a>. Это вам еще один пример
                бессмысленных сравнений в стиле <span>&quot;черного ящика&quot;</span>, о которых
                мы говорили ранее.
            </p>

            <p>
                По моему мнению, причины сильного различия в производительности запросов <code>GROUP
                    BY</code>, которое наблюдали в Uber, стоит искать в недостатке сортировки
                данных в сегментах Druid, как уже было отмечено выше в этом разделе.
            </p>
        </section>

        <!-- У Druid есть более умный алгоритм присваивания (балансировки) сегментов -->
        <section>
            <h3>У Druid есть более умный алгоритм присваивания (балансировки) сегментов</h3>

            <p>
                Алгоритм Pinot заключается в присвоении сегмента к узлам обработки запроса, которые
                имеют наименьшее число сегментов, загруженных в текущий момент. Алгоритм Druid
                является гораздо более сложным; он учитывает таблицу каждого сегмента и время, и
                применяет <strong>сложную формулу для вычисления финального коэффициента</strong>,
                согласно которому будут ранжированы узлы обработки запросов для выбора наилучшего,
                которому и будет присвоен новый сегмент. Этот алгоритм показал ускорение в скорости
                выполнения запросов в продакшне Metamarketsна <b>30-40%</b>. Хотя, даже несмотря на
                подобный результат, мы им по-прежнему не слишком довольны - подробности можно
                прочитать <a href="https://metamarkets.com/2016/distributing-data-in-druid-at-petabyte-scale/"
                    target="_blank">в отдельной статье</a>.
            </p>

            <p>
                Не знаю, как в LinkedIn управляются со всем при помощи настолько простого алгоритма
                балансировки сегментов в Pinot, но, вполне возможно, их ожидают значительные
                улучшения по части производительности, если они решатся потратить время на
                совершенствование используемого ими алгоритма.
            </p>
        </section>

        <!-- Pinot более устойчив к отказам при выполнении сложных запросов -->
        <section>
            <h3>Pinot более устойчив к отказам при выполнении сложных запросов</h3>

            <p>
                Как уже упоминалось выше в разделе <span>&quot;Выполнение запроса&quot;</span>,
                когда брокер-узелсоздает подзапросы к другим узлам, некоторые подзапросы
                заканчиваются ошибкой, но Pinot объединяет результаты всех удачно выполненных
                подзапросов и по-прежнему возвращает частичный результат пользователю.
            </p>

            <p>
                В Druid такой функции на данный момент.
            </p>
        </section>

        <!-- Иерархия узлов обработки запросов в Druid -->
        <section>
            <h3>Иерархия узлов обработки запросов в Druid</h3>

            <p>
                Смотрите аналогичный раздел выше. Druid позволяет вводитьуровни узловобработки
                запросов для старых и новых данных, и для узловсо <span>&quot;старыми&quot;</span>
                данными соотношение <span>&quot;ресурсы CPU, RAM / число загруженныхсегментов&quot;</span>
                гораздо ниже, что позволяет выиграть на расходах на инфраструктуру в обмен на
                низкую производительность запросов при доступе к старым данным.
            </p>

            <p>
                Насколько мне известно, в Pinot на данный момент аналогичная функциональность
                отсутствует.
            </p>
        </section>

    </section>

    <!-- Заключение -->
    <section>
        <h2>Заключение</h2>

        <p>
            <b>ClickHouse, Druid и Pinot имеют фундаментально схожую архитектуру</b>, и занимают
            свою собственную нишу между Big Data-фреймворками общего назначения вроде Impala,
            Presto, Spark, и колоночными базами данных с корректной поддержкой первичных ключей,
            точечных обновлений и удалений, как InfluxDB.
        </p>

        <p>
            В силу схожести архитектур, ClickHouse, Druid и Pinot имеют примерно одинаковый <span>&quot;предел
                оптимизации&quot;</span>. Но в своём текущем состоянии, <strong>все три системы еще
                незрелы</strong> и очень далеки от этого лимита. Существенных улучшений в
            производительности данных систем (применительно к специфическим сценариям
            использования) можно достичь несколькими человеко-месяцами работы опытных инженеров.
        </p>

        <blockquote>
            Я бы не рекомендовал вам сравнивать производительность данных систем между собой
            -выберите для себя ту, чей исходный код вы способны понять и модифицировать, или ту, в
            которую вы хотите инвестировать свои ресурсы.
        </blockquote>

        <p>
            Из этих трех систем, ClickHouse стоит немного в стороне от Druid и Pinot -в то время
            как Druid и Pinotпрактически идентичны, и их можно считать двумя независимо
            разрабатываемыми реализациями одной и той же системы.
        </p>

        <p>
            ClickHouse больше напоминает <span>&quot;традиционные&quot;</span> базы данных вроде
            PostgreSQL. ClickHouse можно установить на один узел. При малых масштабах (менее 1 TB
            памяти, менее 100 ядер CPU), ClickHouse выглядит гораздо более интересным вариантом,
            чем Druid или Pinot -если вам все еще хочется их сравнивать -в силу того, что
            ClickHouse проще и имеет меньше движущихся частей и сервисов. Я бы даже сказал, что на
            таком масштабе он скорее становится конкурентом для InfluxDB или Prometheus, а не
            дляDruid или Pinot.
        </p>

        <p>
            Druid и Pinot больше напоминают другие системы Big Data из экосистемы Hadoop. Они
            сохраняют свои <span>&quot;самоуправляемые&quot;</span> свойства даже на очень больших
            масштабах (более 500 узлов), в то время как ClickHouse потребует для этогодостаточно
            много работы профессиональных SRE. Кроме того, Druid и Pinot занимают выигрышную
            позицию в плане оптимизации инфраструктурной стоимости больших кластеров, и лучше
            подходят для облачных окружений, чем ClickHouse.
        </p>

        <p>
            Единственным долгосрочным различием между Druid и Pinot является то, что Pinot зависит
            от фреймворка Helix и будет продолжать зависеть от ZooKeeper, в то время как Druid
            может уйти от зависимости от ZooKeeper. С другой стороны, установка Druid продолжит
            зависеть от наличия какой-либо SQL-базы данных.На данный момент, Pinot оптимизирован
            лучше, чем Druid.

        </p>

        <blockquote>
            Если вы уже сталкивались с необходимостью сравнения этих систем и сделали свой выбор,
            то приходите на одну из наших конференций и расскажите о своем кейсе: о том какие
            именно были задачи и какие грабли (а наверняка они были) вы встретили. Хотя, конечно,
            базы данных далеко не единственная тема.
        </blockquote>
        <blockquote>
            Ближайший по окончанию срока подачи заявок (<b>до 9 апреля</b>) фестиваль <a href="http://ritfest.ru"
                target="_blank">РИТ++</a> включает направления: <a href="http://frontendconf.ru"
                target="_blank">фронтенд</a>, <a href="http://backendconf.ru/moscow-rit/2019"
                target="_blank">бэкенд</a>, <a href="https://devopsconf.io" target="_blank">эксплуатацию</a>
            и <a href="http://whalerider.ru/moscow-rit/2019" target="_blank">управление</a>.
            Участникам обычно интереснее всего узнать оконкретных примерах, но и выступления и в
            виде обзоров и исследованийтоже возможны–главное, чтобы тема была интересна лично вам.
        </blockquote>
    </section>

</body>

</html>
